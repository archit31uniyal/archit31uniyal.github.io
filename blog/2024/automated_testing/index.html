<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Automated Unit testing | Archit Uniyal </title> <meta name="author" content="Archit Uniyal "> <meta name="description" content="Internship work at OmniVision Technologies"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pseudocode@2.4.1/build/pseudocode.min.css" integrity="sha256-VwMV//xgBPDyRFVSOshhRhzJRDyBmIACniLPpeXNUdc=" crossorigin="anonymous"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://archit31uniyal.github.io/blog/2024/automated_testing/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Archit Uniyal</span> </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <p>In this blog, we will be discussing automated unit testing, various techniques used in the industry and python packages essential for parsing C code. We will also be discussing the approach I developed during my internship at OmniVision Technologies.</p> <h3 id="what-is-unit-testing">What is unit testing?</h3> <p>Unit testing is the process of fragmenting the code into smaller functional units and performing individual tests on these units. Unit testing has become a crucial part of the software testing lifecycle. It enables developers to identify bugs, logical flaws as well as decipher inputs which increase code coverage.</p> <p><a id="fig2"></a></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/7-Stages-of-Software-Testing-Life-Cycle_11.jpg" sizes="95vw"></source> <img src="/assets/img/7-Stages-of-Software-Testing-Life-Cycle_11.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" alt="STLC" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 1. Software Testing Life Cycle</figcaption> </figure> <p>&lt;/a&gt;</p> <p><a href="#fig1">Figure 1</a> highlights the various stages of software testing life cycle (STLC). The first four steps of STLC: test plan, analysis, design, development, require a lot of manual work as well as time to implement. Automated unit testing targets these four steps to reduce the time taken in generating these tests as well as to develop tests with higher code coverage.</p> <p>In the following sections, we will be discussing two most commonly used unit testing techniques: randomized testing and concolic testing.</p> <h3 id="randomized-testing">Randomized Testing</h3> <p>Randomized testing involves testing a program iteratively using random, independent inputs. The example below shows a simple absolute function which takes in as input an integer and returns its absolute value.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span> <span class="c1"># Bug: should be '-x'</span></code></pre></figure> <p>Let’s assume, the random input generator generates {18, 31, 3, 21, -15}. ‘-15’ is the only input which will trigger the bug.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">testAbs</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="o">-</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nf">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="nf">assert</span><span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span></code></pre></figure> <p>A naive randomized unit test generation technique which I explored during my internship included extracting the arguments and their datatypes. The datatype of each argument was used to set a range of values from which a random value would be generated for the corresponding argument.</p> <p>Provided below is an example of a target function</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">execute</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">&gt;</span><span class="mi">20</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="p">){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"GOAL!"</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <p>For the example above, the algorithm would fetch the arguments for the function using its abstract syntax tree (AST). Since both arguments in the example are integers, therefore the random values for <em>a</em> and <em>b</em> would be generated within the range [-2<sup>32</sup>, 2<sup>32</sup>). The GOAL condition would be achieved for all <em>a&gt;20</em> and <em>b&lt;15</em>.</p> <p>Randomized testing leads to generation of similar data and increases time required to generate useful unit tests. An alternative to randomized testing is concolic testing which has shown to be more effective in generating unit tests. Recently, large language models (LLM) have also been utilized to efficiently generate unit tests.</p> <h3 id="concolic-testing">Concolic Testing</h3> <p>Concolic testing can be defined as automation of test input generation process by using the concrete and symbolic, also known as concolic, execution of the code <a href="#2">[Sen, 2007]</a>.</p> <d-cite key="10.1145/1321631.1321746"></d-cite> <p>.</p> <p>As defined above, concolic testing can be divided into two subprocesses:</p> <ol> <li> <strong>Concrete execution:</strong> This subprocess involves the normal execution of the target code with the provided inputs.</li> <li> <strong>Symbolic execution:</strong> This subprocess involves collecting all the symbolic constraints over a set of symbolic inputs at each branch point which is encountered during concrete execution such as conditional statements, function calls, etc.</li> </ol> <p>SMT solvers such as <a href="#3">[yices]</a> and <a href="#4">[z3]</a> are used in the symbolic execution stage to solve the constraints and keep track of the branches which have been explored. </p> <p><a id="fig2"></a></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/Concolic+Testing+Approach.jpg" sizes="95vw"></source> <img src="/assets/img/Concolic+Testing+Approach.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" alt="Concolic testing" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 2. Concolic testing</figcaption> </figure> <p>&lt;/a&gt;</p> <p>Koushik Sen’s example of concolic testing is depicted in <a href="#fig2">Figure 2</a>. It shows how for a given target code the concrete and symbolic execution is performed.</p> <p>As it can be seen, in order to reach the ERROR statement, variables x, y and z were encountered and their symbolic representations were also recorded which were \(x=x_0, y=y_0\) and \(z=2*y\). Additionally, the conditions encountered during the concrete execution were also collected. In order to reach the ERROR statement, both the path conditions must satisfy, hence a symbolic constraint is generated [(2*y_0 == x_0) \land (x_0 &gt; y_0 + 10)]</p> <p>In order to solve the constraint above, an SMT solver can be used which would return values for \(x_0\) and \(y_0\) which would satisfy the constraint.</p> <h4 id="background">Background</h4> <p>In this section, I will be discussing two concolic testing techniques which I studied and implemented as part of my internship. These two algorithm have been adopted by the community and prior work has been done to make these approaches more efficient.</p> <h5 id="direct-automated-random-testing-dart">Direct Automated Random Testing (DART)</h5> <p>DART <a href="#6">[Godefroid, 2005]</a> is a software testing algorithm which automates the process of generating and executing test cases for programs. DART combines three key techniques: </p> <ul> <li> <strong>Interface extraction:</strong> DART can automatically extract the program’s interface by parsing the source code. The interface extracted include external variables, functions and arguments with which the program interacts.</li> <li> <strong>Random test generation:</strong> DART employs a test driver which performs random testing on the extracted interface in order to simulate all possible inputs that the program may encounter.</li> <li> <strong>Dynamic test generation with symbolic execution:</strong> DART also analyzes the program’s control flow during random testing to generate new inputs to explore different execution paths. This is done by collecting symbolic constraints from conditionals statements and systematically solving and directing the program’s execution.</li> </ul> <p>The pseudo code below provides a systematic explanation of how the algorithm functions.</p> <figure class="highlight"><pre><code class="language-pseudocode" data-lang="pseudocode">function DART(program, initial_input): # Initialize with initial random input
    input_queue = [initial_input]
    explored_paths = set()

    while input_queue is not empty:
        # Fetch the next input to test
        input_vector = input_queue.pop()

        # Execute program with current input and generate the executed path and constraints encountered
        execution_trace, path_constraints = execute_program(program, input_vector)

        # Record the current path as explored
        explored_paths.add(execution_trace)

        # For each condition in the path constraints
        for i in range(0, len(path_constraints)):
            # Negate the i-th condition to explore a new path
            new_constraints = negate_condition(path_constraints, i)

            # Check if the new path has been explored
            if new_constraints not in explored_paths:
                # Solve for new input vector using SMT solver
                new_input = solve_constraints(new_constraints)

                # If solvable, add the new input to the queue
                if new_input is not None:
                    input_queue.append(new_input)
                # Mark the path as explored
                explored_paths.add(new_constraints)

    return explored_paths</code></pre></figure> <p>The function DART(…) highlights the core of the algorithm. The algorithm takes random inputs along with the program as arguments, which are later used to generate the execution trace and the path constraints encountered. The execution trace is stored to keep tracks of paths covered. The path constraints are then traveresed to explore different branches in the program by negating each path constraint one at a time. The new path constraints are solved using an SMT solver. If the conditions are satisfied, the new inputs and new constraints are recorded. Lastly, after each condition has been traversed, the explored paths are returned which can be used calculate the code coverage. The paper can be found <a href="https://dl.acm.org/doi/10.1145/1064978.1065036" rel="external nofollow noopener" target="_blank">here</a>.</p> <h5 id="crest---concolic-test-generation-tool-for-c">CREST - Concolic test generation tool for C</h5> <p>CREST <a href="#7">[Burnim, 2008]</a> builds on top of the concept of concolic testing by introducing several heuristic search strategies aimed at improving the effectiveness and scalibility of concolic testing for large software programs. For detailed information on crest, you can visit their website <a href="https://www.burn.im/crest/" rel="external nofollow noopener" target="_blank">here</a>. </p> <p>Listed below are some terminology which will help understand the pseudo code better.</p> <ul> <li> <strong>Termination Condition:</strong> This typically checks if the search has exhausted its iteration budget or met other predefined criteria (e.g., sufficient coverage).</li> <li> <strong>Branch Selection:</strong> Different strategies have their own methods for selecting which branch to explore next.</li> <li> <strong>Forcing Execution:</strong> Forcing a branch means modifying the path conditions to ensure the program follows the desired path during the next execution.</li> <li> <strong>Updating the Control-Flow Graph (CFCG):</strong> This is done to incorporate newly discovered paths into the search strategy, helping the algorithm to explore unexplored branches.</li> <li> <strong>Attempt Counter:</strong> Keeps track of how many times a branch has been forced to avoid redundant or unsuccessful attempts.</li> </ul> <p>The three main strategies in this work are as follows:</p> <ul> <li> <p><strong>Control-Flow Graph (CFG) Directed Search</strong></p> <p>This strategy leverages the control flow graph of a program to direct the testing process. The idea is to prioritize paths that are closer to uncovered branches, thereby improving coverage efficiency.</p> <p><strong>Process</strong></p> <ul> <li>Construct the combined control flow and static call graph (CFCG) for the program.</li> <li>For each branch encountered during execution, calculate the shortest path in the CFCG to any uncovered branch.</li> <li>Force the execution along paths that move closer to these uncovered branches.</li> <li>If a new branch is covered, update the CFCG and continue.</li> </ul> <p><strong>Pseudo Code</strong></p> </li> </ul> <figure class="highlight"><pre><code class="language-pseudocode" data-lang="pseudocode">    function CfgDirectedSearch(program P, initial_path p): # Continue searching until the termination condition is met
        while not termination_condition():

            # Select the branch from the current path that has the shortest distance to any uncovered branch
            branch_to_force = select_branch_with_min_distance_to_uncovered(p)

            # Attempt to force execution along the selected branch to generate a new path
            new_path = force_branch(branch_to_force)

            # Check if forcing the branch led to covering a new branch
            if new_branch_covered(new_path):

                # Update the control flow graph with the newly covered branch
                update_CFCG_with_new_branch()

                # Set the current path to the new path for the next iteration
                p = new_path
            else:
                # If no new branch is covered, increment the attempt counter for the selected branch
                increment_attempt_counter(branch_to_force)

        # Return the set of branches that have been covered by the search
        return covered_branches

    </code></pre></figure> <ul> <li> <p><strong>Uniform Random Search</strong></p> <p>This approach uniformly samples the execution path space by assigning equal probabilities to taking true or false branches during execution.</p> <p><strong>Process</strong></p> <ul> <li>Start from an initial execution path.</li> <li>Randomly decide whether to terminate the current path or pick a branch to force.</li> <li>If a branch is chosen, force it and generate a new path.</li> <li>Continue the process until the desired number of paths are generated.</li> </ul> <p><strong>Pseudo Code</strong></p> </li> </ul> <figure class="highlight"><pre><code class="language-pseudocode" data-lang="pseudocode">    function UniformRandomSearch(program P, path p): # Initialize the position in the current execution path
        i = 0

        # Continue until the termination condition is met
        while not termination_condition():

            # Randomly select a branch from the current path based on a probability distribution
            j = select_random_branch_with_prob(p, i)

            # If a valid branch is selected
            if j is valid:

                # Force the execution along the selected branch to generate a new path
                new_path = force_branch(p, j)

                # Update the current path to the new path
                p = new_path

                # Move the position forward in the path
                i = j + 1
            else:
                # Terminate the search if no valid branch is found to force
                return p

        # Return the final execution path after the search
        return p
    </code></pre></figure> <ul> <li> <p><strong>Random Branch Search</strong></p> <p>A simpler, more practical approach that randomly selects a branch to force at each iteration, focusing on exploration rather than uniformity.</p> <p><strong>Process</strong></p> <ul> <li>At each step, randomly select a branch from the current execution path.</li> <li>Force the branch and update the execution path.</li> <li>If no new branches are covered after a certain number of iterations, restart the search.</li> </ul> <p><strong>Pseudo Code</strong></p> </li> </ul> <figure class="highlight"><pre><code class="language-pseudocode" data-lang="pseudocode">    function RandomBranchSearch(program P, path p): # Continue searching until the termination condition is met
        while not termination_condition():

            # Randomly select a branch from the current execution path
            random_branch = select_random_branch(p)

            # If the selected branch is valid for forcing
            if random_branch is valid:

                # Force the execution along the selected branch to generate a new path
                new_path = force_branch(p, random_branch)

                # Update the current path to the new path
                p = new_path
            else:
                # If no valid branch is found, restart the search with a new input
                restart_search_with_new_input()

        # Return the set of branches that have been covered by the search
        return covered_branches

    </code></pre></figure> <p>Originally, crest was implemented with Yices SMT solver which does not support non-linear operations. Later on, Heechul implemented crest with Z3 solver to enable non-linear operations. The implementation of crest-z3 can be found <a href="https://github.com/heechul/crest-z3" rel="external nofollow noopener" target="_blank">here</a>.</p> <h3 id="depth-first-search-dfs-approach">Depth First Search (DFS) Approach</h3> <p>In this section, we will discussing the DFS based approach I developed during my internship at OmniVision. The key feature of this approach is that it does not require instrumentation and uses the SMT solvers ability to solve symbolic expressions to generate efficient unit test inputs. Furthermore, this approach was implemented in Python which required the dependencies of the software significantly.</p> <p><strong>Instrumentation:</strong> It is a process of modifying software such that analysis can be performed on it. It allows logging the state of variables during test runs, which is an advantage during software testing. DART and Crest use instrumentation to update and monitor the state of the target inputs.</p> <p>The DFS-based approach can be divided into three key stages:</p> <ul> <li> <strong>Traverse and extract information from the abstract syntax tree (AST)</strong> For a given target program, the approach first generates its AST which will be used in the following stages. The AST is then traveresed to generate a binary tree using the conditional statements. The left nodes in the tree represent the true blocks and the right nodes represent the false blocks.</li> <li> <p><strong>Convert conditions to SMT format</strong> In this stage, the conditions in the tree are traversed and converted to the desired SMT format. Additionally, the variables in the symbolic expression are converted to only include the arguments to the target function, if possible. An example of this process is shown below.</p> <p>For a given target function <em>execute</em>,</p> <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">execute</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">){</span>
      <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">){</span>
          <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">&lt;</span><span class="mi">500</span><span class="p">){</span>
          <span class="k">return</span> <span class="n">c</span><span class="o">%</span><span class="n">d</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span>
          <span class="k">return</span> <span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div> </div> <p><a href="#fig3">Figure 3</a> below shows how the binary tree generated for the function <em>execute</em> will look. In this binary tree <em>c</em> will be replaced with ‘\(a+b\)’, which will convert the conditionals to ‘\(a+b&lt;20\)’ and ‘\(a+b&lt;500\)’.</p> <p><a id="fig3"></a></p> </li> </ul> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/BST.png" sizes="95vw"></source> <img src="/assets/img/BST.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" alt="Concolic testing" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Figure 3. Binary tree for execute(...)</figcaption> </figure> <p>&lt;/a&gt;</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The reason for substituting the variables in terms of the arguments is to explore different uncovered paths and generate inputs the SMT solver.
</code></pre></div></div> <ul> <li> <p><strong>DFS traversal</strong></p> <p>In this stage, the acquired binary tree is traversed to discover new paths. The pseudo code below shows the algorithm.</p> <pre><code class="language-pseudocode">  function DFS(node, SMT_solver): 
      # If the node is empty, return since there's no condition to process
      if not node.value:
          return

      # Add the current condition to the path and mark it as visited
      path.append(node.value)
      visited.add(node.value)

      # Traverse the true (left) branch if it exists
      if node.left:
          DFS(node.left, SMT_solver)
          # Solve the path using the SMT solver and store the resulting test inputs
          test_inputs.append(SMT_solver.solve(path))

      # Negate the last condition to explore the false (right) branch
      path[-1] = Negate(path[-1])

      # Traverse the false (right) branch if it exists
      if node.right:
          DFS(node.right, SMT_solver)
          # Solve the path using the SMT solver and store the resulting test inputs
          test_inputs.append(SMT_solver.solve(path))

      # After exploring both branches, solve the path with all conditions negated
      path[-1] = Negate(path[-1])
      test_inputs.append(SMT_solver.solve(path))

      # Return the generated test inputs and the set of visited paths for coverage analysis
      return test_inputs, visited
</code></pre> <p>When <em>DFS</em> is invoked on the tree in <a href="#fig3">fig. 3</a>, it will encounter two conditionals: \(a+b&lt;20\) and \(a+b&lt;500\).</p> <ul> <li> <strong>Initial Path:</strong> The first condition encountered is \(a+b&lt;20\). This path is passed to the SMT solver, which might return \(a = 0\) and \(b = 0\) as solutions satisfying the constraint.</li> <li> <strong>True Branch Traversal:</strong> DFS will then explore the true (left) branch. If it’s None, the path will be modified to \(!(a + b &lt; 20)\), and DFS will proceed to the false (right) branch.</li> <li> <strong>False Branch Traversal:</strong> In this branch, the path becomes \(!(a + b &lt; 20) ∧ (a + b) &lt; 500\). The SMT solver might return \(a = 21\) and \(b = 0\) as solutions.</li> <li> <strong>Final Path:</strong> The final step involves generating a solution for the scenario where all conditions are false, i.e., \(!(a + b &lt; 20) ∧ !(a + b &lt; 500)\). A possible solution could be \(a = 495\) and \(b = 10\).</li> <li> <strong>Termination:</strong> The recursion terminates once all conditions have been explored, and the collected solutions are returned.</li> </ul> <p>This process effectively explores all paths in the tree, generating unit test inputs for each possible path and providing the necessary information to assess code coverage.</p> </li> </ul> <p>This approach was tested on Heechul’s test suite which can be found <a href="https://github.com/heechul/crest-z3/tree/master/test" rel="external nofollow noopener" target="_blank">here</a>. The development of the DFS approach is still in its native stage and requires improvement on including various functionalities such as loops and in-built function calls.</p> <p>During my internship, I was able to implement the following functionalities:</p> <ul> <li>Support for non-linear arithmetic</li> <li>Support for array operations</li> <li>Support for function calling</li> </ul> <h3 id="resources">Resources</h3> <p>In this section, I will providing a short tutorial on the available python packages that can help implement the logic for the DFS approach. We will be exploring two packages in this tutorial:</p> <ul> <li> <strong>pycparser:</strong> parser for parsing c code written in pure Python</li> <li> <strong>z3solver:</strong> python bindings for Z3 SMT solver</li> </ul> <h4 id="pycparser">pycparser</h4> <p>The official documentation for this library can be found <a href="https://github.com/eliben/pycparser" rel="external nofollow noopener" target="_blank">here</a>. The first step in using pycparser is installation, use the following command to install it.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; pip install pycparser
</code></pre></div></div> <p>In order for pycparser to parse C code, it should receive preprocessed C code. In order to preprocess C code we can make use of <code class="language-plaintext highlighter-rouge">cpp</code> which handles preprocessing directives such as <code class="language-plaintext highlighter-rouge">#include</code> and <code class="language-plaintext highlighter-rouge">#define</code>, removes comments and other such tasks to prepare C code for compilation.</p> <p>We can perform this preprocessing using pycparser’s <code class="language-plaintext highlighter-rouge">parse_file</code> function. It will interact with <code class="language-plaintext highlighter-rouge">cpp</code>, provided it’s in the PATH, or a path to it is provided.</p> <p>Alternatives for <code class="language-plaintext highlighter-rouge">cpp</code> are also available such as <code class="language-plaintext highlighter-rouge">gcc</code> and <code class="language-plaintext highlighter-rouge">clang</code> using the <code class="language-plaintext highlighter-rouge">-E</code> flag. An example on how to use <code class="language-plaintext highlighter-rouge">parse_file</code> is provided below.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="n">pycparser</span> <span class="kn">import</span> <span class="n">parse_file</span>

<span class="n">ast</span> <span class="o">=</span> <span class="nf">parse_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">use_cpp</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
            <span class="n">cpp_path</span><span class="o">=</span><span class="sh">'</span><span class="s">gcc</span><span class="sh">'</span><span class="p">,</span>
            <span class="n">cpp_args</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">-E</span><span class="sh">'</span><span class="p">,</span> <span class="sa">r</span><span class="sh">'</span><span class="s">-Iutils/fake_libc_include</span><span class="sh">'</span><span class="p">])</span></code></pre></figure> <p><code class="language-plaintext highlighter-rouge">filename</code> refers to the path to the C program. The code above will help in attaining the abstract syntax tree (AST) of the C code. The next step is to traverse the AST.</p> <p>For instance, the C code under consideration is as follows.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <p>The following code will help traverse the AST for if conditions.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="kn">from</span> <span class="n">pycparser</span> <span class="kn">import</span> <span class="n">parse_file</span><span class="p">,</span> <span class="n">c_ast</span>

    <span class="n">ast</span> <span class="o">=</span> <span class="nf">parse_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">use_cpp</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                <span class="n">cpp_path</span><span class="o">=</span><span class="sh">'</span><span class="s">gcc</span><span class="sh">'</span><span class="p">,</span>
                <span class="n">cpp_args</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">-E</span><span class="sh">'</span><span class="p">,</span> <span class="sa">r</span><span class="sh">'</span><span class="s">-Iutils/fake_libc_include</span><span class="sh">'</span><span class="p">])</span>

    <span class="c1"># Function to recursively traverse the AST and find if conditions
</span>    <span class="k">def</span> <span class="nf">find_if_conditions</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">c_ast</span><span class="p">.</span><span class="n">If</span><span class="p">):</span>
            <span class="c1"># Print the condition of the if statement
</span>            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span> <span class="o">*</span> <span class="n">indent</span> <span class="o">+</span> <span class="sa">f</span><span class="sh">"</span><span class="s">If condition found: </span><span class="si">{</span><span class="n">node</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">coord</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span> <span class="o">*</span> <span class="n">indent</span> <span class="o">+</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Condition: </span><span class="si">{</span><span class="n">node</span><span class="p">.</span><span class="n">cond</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

        <span class="c1"># Recursively traverse child nodes
</span>        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="nf">find_if_conditions</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

    <span class="nf">find_if_conditions</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span></code></pre></figure> <p>The output will look something like this</p> <figure class="highlight"><pre><code class="language-mathematica" data-lang="mathematica"><span class="nb">If</span><span class="w"> </span><span class="nv">condition</span><span class="w"> </span><span class="nv">found</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="o">&lt;</span><span class="nv">c</span><span class="o">_</span><span class="nv">code</span><span class="o">&gt;:</span><span class="m">5</span><span class="o">:</span><span class="m">5</span><span class="o">:</span><span class="w">
</span><span class="nb">Condition</span><span class="o">:</span><span class="w">
    </span><span class="nv">BinaryOp</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;</span><span class="p">)</span><span class="w">
    </span><span class="nv">ID</span><span class="o">:</span><span class="w"> </span><span class="nv">x</span><span class="w">
    </span><span class="nb">Constant</span><span class="o">:</span><span class="w"> </span><span class="nv">int</span><span class="o">,</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="nb">If</span><span class="w"> </span><span class="nv">condition</span><span class="w"> </span><span class="nv">found</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="o">&lt;</span><span class="nv">c</span><span class="o">_</span><span class="nv">code</span><span class="o">&gt;:</span><span class="m">9</span><span class="o">:</span><span class="m">5</span><span class="o">:</span><span class="w">
</span><span class="nb">Condition</span><span class="o">:</span><span class="w">
    </span><span class="nv">BinaryOp</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="p">)</span><span class="w">
    </span><span class="nv">ID</span><span class="o">:</span><span class="w"> </span><span class="nv">x</span><span class="w">
    </span><span class="nb">Constant</span><span class="o">:</span><span class="w"> </span><span class="nv">int</span><span class="o">,</span><span class="w"> </span><span class="m">20</span></code></pre></figure> <p>The output can then be converted into SMT format to be processed by a solver using z3-solver python binding which will be discussed in the next section.</p> <p>Since we can now extract the if statements, we can build our binary tree accordingly by assigning conditions in the <code class="language-plaintext highlighter-rouge">iftrue</code> block in the AST to the left node and the conditions in the <code class="language-plaintext highlighter-rouge">iffalse</code> block in the AST to the right node.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="k">class</span> <span class="nc">BinaryTreeNode</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
            <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">convert2binary</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">c_ast</span><span class="p">.</span><span class="n">If</span><span class="p">):</span>
            <span class="c1"># call binary node creator function
</span>            <span class="k">return</span> <span class="nf">handle_if</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># Recursively traverse child nodes and append the return BinaryTreeNode object to tree
</span>        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">tree</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">convert2binary</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">handle_if</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">cond</span>
        <span class="n">if_true</span> <span class="o">=</span> <span class="nf">convert2binary</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">iftrue</span><span class="p">)</span>
        <span class="n">if_false</span> <span class="o">=</span> <span class="nf">convert2binary</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">iffalse</span><span class="p">)</span>
        <span class="k">return</span> <span class="nc">BinaryTreeNode</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">if_true</span><span class="p">,</span> <span class="n">if_false</span><span class="p">)</span></code></pre></figure> <p>The complete code will look as follows:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="kn">from</span> <span class="n">pycparser</span> <span class="kn">import</span> <span class="n">parse_file</span><span class="p">,</span> <span class="n">c_ast</span>

    <span class="n">ast</span> <span class="o">=</span> <span class="nf">parse_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">use_cpp</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                <span class="n">cpp_path</span><span class="o">=</span><span class="sh">'</span><span class="s">gcc</span><span class="sh">'</span><span class="p">,</span>
                <span class="n">cpp_args</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">-E</span><span class="sh">'</span><span class="p">,</span> <span class="sa">r</span><span class="sh">'</span><span class="s">-Iutils/fake_libc_include</span><span class="sh">'</span><span class="p">])</span>

    <span class="k">class</span> <span class="nc">BinaryTreeNode</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
            <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">convert2binary</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">c_ast</span><span class="p">.</span><span class="n">If</span><span class="p">):</span>
            <span class="c1"># call binary node creator function
</span>            <span class="k">return</span> <span class="nf">handle_if</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># Recursively traverse child nodes and append the return BinaryTreeNode object to tree
</span>        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">tree</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">convert2binary</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">handle_if</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">cond</span>
        <span class="n">if_true</span> <span class="o">=</span> <span class="nf">convert2binary</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">iftrue</span><span class="p">)</span>
        <span class="n">if_false</span> <span class="o">=</span> <span class="nf">convert2binary</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">iffalse</span><span class="p">)</span>
        <span class="k">return</span> <span class="nc">BinaryTreeNode</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">if_true</span><span class="p">,</span> <span class="n">if_false</span><span class="p">)</span>

    <span class="nf">convert2binary</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span></code></pre></figure> <h4 id="z3-solver">Z3 Solver</h4> <p>In this section, we will discussing how to use the z3 solver library to convert expression from the AST to Z3 format as well as how to use solve Z3 to solve symbolic expressions. The official documentation for Z3 can be found <a href="https://z3prover.github.io/api/html/z3.html" rel="external nofollow noopener" target="_blank">here</a>.</p> <p>Z3 can be installed in python using the following command:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; pip install z3-solver
</code></pre></div></div> <p>Converting a binary operation to Z3 format expression</p> <figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="kn">from</span> <span class="n">z3</span> <span class="kn">import</span> <span class="o">*</span>
    <span class="kn">from</span> <span class="n">pycparser</span> <span class="kn">import</span> <span class="n">c_ast</span>

    <span class="k">def</span> <span class="nf">convert_to_z3_format</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">c_ast</span><span class="p">.</span><span class="n">BinaryOp</span><span class="p">):</span>
            <span class="n">left</span> <span class="o">=</span> <span class="nf">convert_to_z3_format</span><span class="p">(</span><span class="n">cond</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nf">convert_to_z3_format</span><span class="p">(</span><span class="n">cond</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">cond</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="sh">'</span><span class="s">==</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span> <span class="o">==</span> <span class="n">right</span>
            <span class="k">elif</span> <span class="n">cond</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="sh">'</span><span class="s">!=</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span> <span class="o">!=</span> <span class="n">right</span>
            <span class="k">elif</span> <span class="n">cond</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="sh">'</span><span class="s">&lt;</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span>
            <span class="k">elif</span> <span class="n">cond</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="sh">'</span><span class="s">&gt;</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span>
            <span class="k">elif</span> <span class="n">cond</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="sh">'</span><span class="s">&lt;=</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span>
            <span class="k">elif</span> <span class="n">cond</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="sh">'</span><span class="s">&gt;=</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span>
            <span class="k">elif</span> <span class="n">cond</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="sh">'</span><span class="s">&amp;&amp;</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="nc">And</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cond</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="sh">'</span><span class="s">||</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="nc">Or</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cond</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="sh">'</span><span class="s">+</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span>
            <span class="k">elif</span> <span class="n">cond</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span> <span class="o">-</span> <span class="n">right</span>
            <span class="k">elif</span> <span class="n">cond</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span> <span class="o">*</span> <span class="n">right</span>
            <span class="k">elif</span> <span class="n">cond</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="sh">'</span><span class="s">/</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span> <span class="o">/</span> <span class="n">right</span>

        <span class="k">elif</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">c_ast</span><span class="p">.</span><span class="n">ID</span><span class="p">):</span>
            <span class="k">return</span> <span class="nc">Int</span><span class="p">(</span><span class="n">cond</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">c_ast</span><span class="p">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cond</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="sh">'</span><span class="s">int</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">return</span> <span class="nc">IntVal</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">cond</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="nc">Exception</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Unsupported constant type: </span><span class="si">{</span><span class="n">cond</span><span class="p">.</span><span class="nb">type</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">Exception</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Unsupported condition: </span><span class="si">{</span><span class="nf">type</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span></code></pre></figure> <p>The function <code class="language-plaintext highlighter-rouge">convert_to_z3_format</code> takes as input a condition extraction from the AST as shown in the previous section and converts it to a format which can be solved using the Z3 solver.</p> <p>For instance when <code class="language-plaintext highlighter-rouge">convert_to_z3_format</code> is called on the following condition,</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Condition:
    BinaryOp (op: &gt;)
    ID: x
    Constant: int, 5
</code></pre></div></div> <p>the output would be $x&gt;5$ which can now be solved using the z3 solver as it of type <code class="language-plaintext highlighter-rouge">z3.ArithRef</code>.</p> <h5 id="solving-symbolic-expressions">Solving symbolic expressions</h5> <p>In this subsection, I will be discussing on solving symbolic expression using the Z3 solver. In order to understand the process of solving symbolic constraints using Z3, there are certains functions that one should be familiar with. For a detailed guide to Z3, please visit <a href="https://ericpony.github.io/z3py-tutorial/guide-examples.htm" rel="external nofollow noopener" target="_blank">here</a>.</p> <ul> <li> <p>z3.Solver(): It creates a general purpose solver to which new constraints can be added or delete from.</p> <p>Example,</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>s = z3.Solver()
</code></pre></div> </div> </li> <li>add(): This method allows us to add new constraints to the solver. Example, <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  x = Int('x')
  y = Int('y')
  s.add(x &gt; 10, y == x + 2)
</code></pre></div> </div> </li> <li>check(): The method <em>check()</em> solves the asserted constraints. It returns <em>sat</em> if a solution is found, else <em>unsat</em> is returned.</li> <li>push(): The command <em>push</em> creates a new scope by saving the current stack size.</li> <li>pop(): The command <em>pop</em> restores the state of solver by removing any assertion performed between it and the matching <em>push</em>.</li> <li>model(): The method <em>model()</em> provides us with the inputs that satisfy the constraints, if <em>check()</em> returns <em>sat</em>.</li> </ul> <p>Provided below is a simple example on how z3 solver can be used to attain inputs.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="kn">from</span> <span class="n">z3</span> <span class="kn">import</span> <span class="o">*</span>

    <span class="k">def</span> <span class="nf">solve_constraints</span><span class="p">(</span><span class="n">conds</span><span class="p">):</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="nc">Solver</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cond</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">:</span>
            <span class="n">solver</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">solver</span><span class="p">.</span><span class="nf">check</span><span class="p">():</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">model</span>
            <span class="nf">print </span><span class="p">(</span><span class="sh">"</span><span class="s">traversing model...</span><span class="sh">"</span><span class="p">)</span>
            <span class="c1"># print the variables and their values required to solve the constraints
</span>            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">m</span><span class="p">.</span><span class="nf">decls</span><span class="p">():</span>
                <span class="nf">print </span><span class="p">(</span><span class="sh">"</span><span class="s">%s = %s</span><span class="sh">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="nf">name</span><span class="p">(),</span> <span class="n">m</span><span class="p">[</span><span class="n">d</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">model</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="nc">Real</span><span class="p">(</span><span class="sh">'</span><span class="s">x y z</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">conds</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">z</span> <span class="o">-</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">]</span>
    <span class="n">solved_values</span> <span class="o">=</span> <span class="nf">solve_constraints</span><span class="p">(</span><span class="n">conds</span><span class="p">)</span></code></pre></figure> <p>Through this tutorial we have learnt how to parse C code using pycparser, convert the conditions to Z3 compatible format and solve them using Z3 solver. Now we can implement the DFS algorithm and explore more functionalities that pycparser and Z3 have to offer. Thank you for reading!</p> <h3 id="references">References</h3> <p><a id="1">[1]</a> https://www.initialyze.com/insights/unit-testing</p> <p><a id="2">[2]</a> Koushik Sen. 2007. Concolic testing. In Proceedings of the 22nd IEEE/ACM International Conference on Automated Software Engineering (ASE ‘07). Association for Computing Machinery, New York, NY, USA, 571–572. https://doi.org/10.1145/1321631.1321746</p> <d-appendix></d-appendix> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Archit Uniyal . Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0}};</script> <script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/pseudocode@2.4.1/build/pseudocode.min.js" integrity="sha256-aVkDxqyzrB+ExUsOY9PdyelkDhn/DfrjWu08aVpqNlo=" crossorigin="anonymous"></script> <script>document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-pseudocode").forEach(e=>{const t=e.textContent,d=e.parentElement.parentElement;let n=document.createElement("pre");n.classList.add("pseudocode");const o=document.createTextNode(t);n.appendChild(o),d.appendChild(n),d.removeChild(e.parentElement),pseudocode.renderElement(n)})});</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"About",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"Blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-publications",title:"Publications",description:"Publications by categories in reversed chronological order",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"nav-cv",title:"CV",description:"This is a description of the page. You can modify it in &#39;_pages/cv.md&#39;. You can also change or remove the top pdf download button.",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"post-automated-unit-testing",title:"Automated Unit\xa0testing",description:"Internship work at OmniVision Technologies",section:"Posts",handler:()=>{window.location.href="/blog/2024/automated_testing/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%61.%75%6E%69%79%61%6C@%76%69%72%67%69%6E%69%61.%65%64%75","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=BBTWgB8AAAAJ&hl=en","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/archit31uniyal","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/uniyalarchit","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>